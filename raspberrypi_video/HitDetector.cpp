#include "HitDetector.h"

#include <iostream>

#include "opencv2/opencv.hpp"
#include "opencv2/bgsegm.hpp"

using namespace cv;

#define WINDOW_WIDTH 320
#define WINDOW_HEIGHT 240

// background subtractor params
#define BG_HISTORY 500
#define BG_NMIXTURES 5
#define BG_RATIO 0.7
#define BG_VAR_THRESH 10
#define BG_SHADOW_DETECTION false

// blob params
#define MIN_THRESH 10
#define MAX_THRESH 100
#define THRESH_STEP 10
#define MIN_INERTIA 0.1
#define MAX_INERTIA 1
#define MIN_AREA 1
#define MAX_AREA 100
#define MIN_CIRCULARITY 0.01
#define MAX_CIRCULATITY 1


HitDetector::HitDetector(void) {	
	//create background subtractor objects
	pMOG2 = createBackgroundSubtractorMOG2(BG_HISTORY, BG_VAR_THRESH, BG_SHADOW_DETECTION); //MOG2 approach	
	pMOG2->setNMixtures(BG_NMIXTURES);
	pMOG2->setBackgroundRatio(BG_RATIO);
	// can use GMG, KNN or CNT additionally
	
	//create GUI windows
	namedWindow("FG Mask MOG2", WINDOW_NORMAL);
	resizeWindow("FG Mask MOG2", WINDOW_WIDTH, WINDOW_HEIGHT);
	namedWindow("hitpoints", WINDOW_NORMAL);
	resizeWindow("hitpoints", WINDOW_WIDTH, WINDOW_HEIGHT);
	
	//create blob detector objects
	SimpleBlobDetector::Params blobParam;
	blobParam.filterByColor = false;
	blobParam.minThreshold = MIN_THRESH;
	blobParam.maxThreshold = MAX_THRESH;
	blobParam.thresholdStep = THRESH_STEP;
	blobParam.filterByConvexity = false;
	blobParam.filterByInertia = true;
	blobParam.minInertiaRatio = MIN_INERTIA;
	blobParam.maxInertiaRatio = MAX_INERTIA;
	blobParam.filterByArea = true;
	blobParam.minArea = MIN_AREA;
	blobParam.maxArea = MAX_AREA;
	blobParam.filterByCircularity = true;
	blobParam.minCircularity = MIN_CIRCULARITY;
	blobParam.maxCircularity = MAX_CIRCULATITY;
	blobDetector = SimpleBlobDetector::create(blobParam);
	
}

HitDetector::~HitDetector(void) {
}

void HitDetector::detectHit(Mat img) {
	
	Mat foregroundImg = backgroundSubtract(img);
	blobDetect(foregroundImg);
	
}

Mat HitDetector::backgroundSubtract(Mat inputImg) {
	
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	
	//update the background model
    pMOG2->apply(inputImg, fgMaskMOG2);
	
	//show the current frame and the fg masks
    imshow("FG Mask MOG2", fgMaskMOG2);
	
	//return one of the two method results
	return fgMaskMOG2;
	
}

void HitDetector::blobDetect(Mat image) {
	
	// Detect blobs.
	std::vector<KeyPoint> keypoints;
	blobDetector->detect(image, keypoints);
	
	for(uint i=0; i<keypoints.size(); i++) {
		printf("Hit detected, coordinates:\n");
		printf("%s %f %s %f\n", "xCoord = ", keypoints[i].pt.x, ", yCoord = ", keypoints[i].pt.y);
	}
	 
	// Draw detected blobs as red circles.
	// DrawMatchesFlags::DRAW_RICH_KEYPOINTS flag ensures the size of the circle corresponds to the size of blob
	Mat im_with_keypoints;
	drawKeypoints(image, keypoints, im_with_keypoints, Scalar(0,0,255), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);
	 
	// Show blobs
	imshow("hitpoints", im_with_keypoints);
	//waitKey(0);
	
}